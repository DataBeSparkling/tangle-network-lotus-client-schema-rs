//go:build !windows

package main

import (
	"fmt"
	"os"
	"reflect"
	"regexp"
	"strings"
	"text/template"

	"github.com/filecoin-project/lotus/api"
)

type MethodInfo struct {
	Name           string
	IsSubscription bool
	Params         []ParamInfo
	Returns        []ReturnInfo
}

type ParamInfo struct {
	Name string
	Type string
}

type ReturnInfo struct {
	Type string
}

func rustType(t reflect.Type) string {
	// Special case for channels to maintain subscription support
	if t.Kind() == reflect.Chan {
		return fmt.Sprintf("mpsc::Receiver<%s>", "Value")
	}
	// Everything else is just Value
	return "Value"
}

// Add this function before main()
func toSnakeCase(str string) string {
	var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

func hasSuffix(s, suffix string) bool {
	return strings.HasSuffix(s, suffix)
}

func trimSuffix(s, suffix string) string {
	return strings.TrimSuffix(s, suffix)
}

func main() {
	var t reflect.Type
	var apiName string

	switch apiArg := os.Args[1]; apiArg {
	case "Common":
		var api struct{ api.Common }
		t = reflect.TypeOf(api)
		apiName = "Common"
	case "FullNode":
		var api struct{ api.FullNode }
		t = reflect.TypeOf(api)
		apiName = "FullNode"
	case "StorageMiner":
		var api struct{ api.StorageMiner }
		t = reflect.TypeOf(api)
		apiName = "StorageMiner"
	case "Gateway":
		var api struct{ api.Gateway }
		t = reflect.TypeOf(api)
		apiName = "Gateway"
	case "Wallet":
		var api struct{ api.Wallet }
		t = reflect.TypeOf(api)
		apiName = "Wallet"
	case "Worker":
		var api struct{ api.Worker }
		t = reflect.TypeOf(api)
		apiName = "Worker"
	default:
		panic("Unknown API")
	}

	methods := make([]MethodInfo, 0)
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)

		method := MethodInfo{
			Name:           m.Name,
			IsSubscription: false,
			Params:         make([]ParamInfo, 0),
			Returns:        make([]ReturnInfo, 0),
		}

		// Handle parameters
		for j := 1; j < m.Type.NumIn(); j++ {
			paramType := m.Type.In(j)
			method.Params = append(method.Params, ParamInfo{
				Name: fmt.Sprintf("param%d", j),
				Type: rustType(paramType),
			})
		}

		// Handle return values
		for j := 0; j < m.Type.NumOut(); j++ {
			returnType := m.Type.Out(j)
			if j == 0 && returnType.Kind() == reflect.Chan {
				method.IsSubscription = true
			}
			method.Returns = append(method.Returns, ReturnInfo{
				Type: rustType(returnType),
			})
		}

		methods = append(methods, method)
	}

	// Generate Rust code
	tmpl := template.Must(template.New("rust").Funcs(template.FuncMap{
		"to_snake_case": toSnakeCase,
		"hasSuffix":     hasSuffix,
		"trimSuffix":    trimSuffix,
	}).Parse(`// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.
	
	use serde::{Deserialize, Serialize};
	use jsonrpc_core::Error;
	use serde_json::Value;
	use tokio::sync::mpsc;
	use crate::client::LotusClient;
	
	#[async_trait::async_trait]
	pub trait {{.ApiName}}Api {
		{{range .Methods}}
	async fn {{.Name | to_snake_case}}(&self{{range .Params}}, {{.Name}}: {{.Type}}{{end}}) 
    -> Result<{{if .Returns}}{{(index .Returns 0).Type}}{{else}}(){{end}}, Error>;
		{{end}}
	}
	
	#[derive(Debug, Clone)]
	pub struct {{.ApiName}}Client {
		client: LotusClient,
	}
	
	#[async_trait::async_trait]
	impl {{.ApiName}}Api for {{.ApiName}}Client {
		{{range .Methods}}
	async fn {{.Name | to_snake_case}}(&self{{range .Params}}, {{.Name}}: {{.Type}}{{end}}) 
    -> Result<{{if .Returns}}{{(index .Returns 0).Type}}{{else}}(){{end}}, Error> {
			{{if .IsSubscription}}
			self.client.subscribe("{{.Name}}", vec![{{range .Params}}{{.Name}},{{end}}]).await
			{{else}}
			self.client.request("{{.Name}}", vec![{{range .Params}}{{.Name}},{{end}}]).await
			{{end}}
		}
		{{end}}
	}`))

	data := struct {
		ApiName string
		Methods []MethodInfo
	}{
		ApiName: apiName,
		Methods: methods,
	}

	err := tmpl.Execute(os.Stdout, data)
	if err != nil {
		panic(err)
	}
}

func format(format string, args ...interface{}) string {
	return fmt.Sprintf(format, args...)
}
