// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.
	
	use serde::{Deserialize, Serialize};
	use jsonrpc_core::Error;
	use serde_json::Value;
	use tokio::sync::mpsc;
	use crate::client::LotusClient;
	
	#[async_trait::async_trait]
	pub trait FullNodeApi {
		
	async fn auth_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn auth_verify(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn beacon_get_entry(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_blockstore_info(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn chain_check_blockstore(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn chain_delete_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_export(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn chain_get_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_block_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_genesis(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_message(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_messages_in_tipset(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_node(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_parent_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_parent_receipts(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_path(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_tip_set(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_tip_set_after_height(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn chain_get_tip_set_by_height(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn chain_has_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_head(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn chain_notify(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn chain_read_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_set_head(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn chain_stat_obj(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn chain_tip_set_weight(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_calc_comm_p(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_cancel_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn client_cancel_retrieval_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_data_transfer_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn client_deal_piece_cid(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_deal_size(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_export(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn client_find_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn client_gen_car(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn client_get_deal_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_get_deal_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_get_deal_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn client_get_retrieval_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn client_has_local(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_list_data_transfers(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn client_list_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn client_list_imports(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn client_list_retrievals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn client_miner_query_offer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn client_query_ask(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn client_remove_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_restart_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn client_retrieve(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_retrieve_try_restart_insufficient_funds(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_retrieve_wait(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_start_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn client_stateless_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn closing(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn create_backup(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn discover(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn gas_estimate_fee_cap(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn gas_estimate_gas_limit(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn gas_estimate_gas_premium(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn gas_estimate_message_gas(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn id(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_alerts(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_set_level(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn market_add_balance(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn market_get_reserved(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn market_release_funds(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn market_reserve_funds(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn market_withdraw(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn miner_create_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn miner_get_base_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_batch_push(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_batch_push_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_batch_push_untrusted(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_check_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_check_pending_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_check_replace_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_clear(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_get_config(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_get_nonce(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_pending(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_push(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_push_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_push_untrusted(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_select(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_set_config(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mpool_sub(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn msig_add_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error>;
		
	async fn msig_add_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error>;
		
	async fn msig_add_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn msig_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn msig_approve_txn_hash(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value, param8: Value, param9: Value) 
    -> Result<Value, Error>;
		
	async fn msig_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn msig_cancel_txn_hash(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value, param8: Value) 
    -> Result<Value, Error>;
		
	async fn msig_create(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error>;
		
	async fn msig_get_available_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn msig_get_pending(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn msig_get_vested(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn msig_get_vesting_schedule(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn msig_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error>;
		
	async fn msig_remove_signer(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn msig_swap_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error>;
		
	async fn msig_swap_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error>;
		
	async fn msig_swap_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn net_addrs_listen(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_agent_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_auto_nat_status(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats_by_peer(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats_by_protocol(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_add(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_connectedness(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_disconnect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_find_peer(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_peer_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_peers(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_pubsub_scores(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn node_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_allocate_lane(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_available_funds(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_available_funds_by_from_to(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn paych_collect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_get(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn paych_get_wait_ready(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn paych_new_payment(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn paych_settle(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_add(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_check_spendable(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_check_valid(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_create(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_list(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn paych_voucher_submit(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn session(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn shutdown(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn state_account_key(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_all_miner_faults(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_call(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_changed_actors(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_circulating_supply(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_compute(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_deal_provider_collateral_bounds(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_decode_params(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn state_encode_params(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_get_actor(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_get_randomness_from_beacon(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn state_get_randomness_from_tickets(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn state_list_actors(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_list_messages(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_list_miners(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_lookup_id(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_market_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_market_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_market_participants(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_market_storage_deal(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_active_sectors(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_available_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_deadlines(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_faults(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_info(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_initial_pledge_collateral(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_partitions(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_power(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_pre_commit_deposit_for_power(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_proving_deadline(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_recoveries(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_sector_allocated(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_sector_count(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_miner_sectors(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_network_name(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn state_network_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_read_state(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_replay(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_search_msg(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn state_sector_expiration(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_sector_get_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_sector_partition(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_sector_pre_commit_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn state_vm_circulating_supply_internal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_verified_client_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_verified_registry_root_key(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn state_verifier_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn state_wait_msg(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn sync_check_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sync_checkpoint(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sync_incoming_blocks(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn sync_mark_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sync_state(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sync_submit_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sync_unmark_all_bad(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sync_unmark_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sync_validate_tipset(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn version(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_balance(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_default_address(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_delete(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_export(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_has(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_set_default(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_sign(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_sign_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_validate_address(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn wallet_verify(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	}
	
	#[derive(Debug, Clone)]
	pub struct FullNodeClient {
		client: LotusClient,
	}
	
	#[async_trait::async_trait]
	impl FullNodeApi for FullNodeClient {
		
	async fn auth_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("AuthNew", vec![param1,param2,]).await
			
		}
		
	async fn auth_verify(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("AuthVerify", vec![param1,param2,]).await
			
		}
		
	async fn beacon_get_entry(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("BeaconGetEntry", vec![param1,param2,]).await
			
		}
		
	async fn chain_blockstore_info(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainBlockstoreInfo", vec![param1,]).await
			
		}
		
	async fn chain_check_blockstore(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainCheckBlockstore", vec![param1,]).await
			
		}
		
	async fn chain_delete_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainDeleteObj", vec![param1,param2,]).await
			
		}
		
	async fn chain_export(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("ChainExport", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn chain_get_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetBlock", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_block_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetBlockMessages", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_genesis(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetGenesis", vec![param1,]).await
			
		}
		
	async fn chain_get_message(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetMessage", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_messages_in_tipset(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetMessagesInTipset", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_node(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetNode", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_parent_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetParentMessages", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_parent_receipts(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetParentReceipts", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_path(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetPath", vec![param1,param2,param3,]).await
			
		}
		
	async fn chain_get_tip_set(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetTipSet", vec![param1,param2,]).await
			
		}
		
	async fn chain_get_tip_set_after_height(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetTipSetAfterHeight", vec![param1,param2,param3,]).await
			
		}
		
	async fn chain_get_tip_set_by_height(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainGetTipSetByHeight", vec![param1,param2,param3,]).await
			
		}
		
	async fn chain_has_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainHasObj", vec![param1,param2,]).await
			
		}
		
	async fn chain_head(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainHead", vec![param1,]).await
			
		}
		
	async fn chain_notify(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("ChainNotify", vec![param1,]).await
			
		}
		
	async fn chain_read_obj(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainReadObj", vec![param1,param2,]).await
			
		}
		
	async fn chain_set_head(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainSetHead", vec![param1,param2,]).await
			
		}
		
	async fn chain_stat_obj(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainStatObj", vec![param1,param2,param3,]).await
			
		}
		
	async fn chain_tip_set_weight(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ChainTipSetWeight", vec![param1,param2,]).await
			
		}
		
	async fn client_calc_comm_p(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientCalcCommP", vec![param1,param2,]).await
			
		}
		
	async fn client_cancel_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientCancelDataTransfer", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn client_cancel_retrieval_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientCancelRetrievalDeal", vec![param1,param2,]).await
			
		}
		
	async fn client_data_transfer_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("ClientDataTransferUpdates", vec![param1,]).await
			
		}
		
	async fn client_deal_piece_cid(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientDealPieceCID", vec![param1,param2,]).await
			
		}
		
	async fn client_deal_size(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientDealSize", vec![param1,param2,]).await
			
		}
		
	async fn client_export(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientExport", vec![param1,param2,param3,]).await
			
		}
		
	async fn client_find_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientFindData", vec![param1,param2,param3,]).await
			
		}
		
	async fn client_gen_car(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientGenCar", vec![param1,param2,param3,]).await
			
		}
		
	async fn client_get_deal_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientGetDealInfo", vec![param1,param2,]).await
			
		}
		
	async fn client_get_deal_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientGetDealStatus", vec![param1,param2,]).await
			
		}
		
	async fn client_get_deal_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("ClientGetDealUpdates", vec![param1,]).await
			
		}
		
	async fn client_get_retrieval_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("ClientGetRetrievalUpdates", vec![param1,]).await
			
		}
		
	async fn client_has_local(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientHasLocal", vec![param1,param2,]).await
			
		}
		
	async fn client_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientImport", vec![param1,param2,]).await
			
		}
		
	async fn client_list_data_transfers(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientListDataTransfers", vec![param1,]).await
			
		}
		
	async fn client_list_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientListDeals", vec![param1,]).await
			
		}
		
	async fn client_list_imports(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientListImports", vec![param1,]).await
			
		}
		
	async fn client_list_retrievals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientListRetrievals", vec![param1,]).await
			
		}
		
	async fn client_miner_query_offer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientMinerQueryOffer", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn client_query_ask(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientQueryAsk", vec![param1,param2,param3,]).await
			
		}
		
	async fn client_remove_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientRemoveImport", vec![param1,param2,]).await
			
		}
		
	async fn client_restart_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientRestartDataTransfer", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn client_retrieve(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientRetrieve", vec![param1,param2,]).await
			
		}
		
	async fn client_retrieve_try_restart_insufficient_funds(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientRetrieveTryRestartInsufficientFunds", vec![param1,param2,]).await
			
		}
		
	async fn client_retrieve_wait(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientRetrieveWait", vec![param1,param2,]).await
			
		}
		
	async fn client_start_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientStartDeal", vec![param1,param2,]).await
			
		}
		
	async fn client_stateless_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ClientStatelessDeal", vec![param1,param2,]).await
			
		}
		
	async fn closing(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("Closing", vec![param1,]).await
			
		}
		
	async fn create_backup(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("CreateBackup", vec![param1,param2,]).await
			
		}
		
	async fn discover(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Discover", vec![param1,]).await
			
		}
		
	async fn gas_estimate_fee_cap(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("GasEstimateFeeCap", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn gas_estimate_gas_limit(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("GasEstimateGasLimit", vec![param1,param2,param3,]).await
			
		}
		
	async fn gas_estimate_gas_premium(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("GasEstimateGasPremium", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn gas_estimate_message_gas(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("GasEstimateMessageGas", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn id(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ID", vec![param1,]).await
			
		}
		
	async fn log_alerts(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogAlerts", vec![param1,]).await
			
		}
		
	async fn log_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogList", vec![param1,]).await
			
		}
		
	async fn log_set_level(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogSetLevel", vec![param1,param2,param3,]).await
			
		}
		
	async fn market_add_balance(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketAddBalance", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn market_get_reserved(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketGetReserved", vec![param1,param2,]).await
			
		}
		
	async fn market_release_funds(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketReleaseFunds", vec![param1,param2,param3,]).await
			
		}
		
	async fn market_reserve_funds(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketReserveFunds", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn market_withdraw(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketWithdraw", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn miner_create_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MinerCreateBlock", vec![param1,param2,]).await
			
		}
		
	async fn miner_get_base_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MinerGetBaseInfo", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn mpool_batch_push(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolBatchPush", vec![param1,param2,]).await
			
		}
		
	async fn mpool_batch_push_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolBatchPushMessage", vec![param1,param2,param3,]).await
			
		}
		
	async fn mpool_batch_push_untrusted(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolBatchPushUntrusted", vec![param1,param2,]).await
			
		}
		
	async fn mpool_check_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolCheckMessages", vec![param1,param2,]).await
			
		}
		
	async fn mpool_check_pending_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolCheckPendingMessages", vec![param1,param2,]).await
			
		}
		
	async fn mpool_check_replace_messages(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolCheckReplaceMessages", vec![param1,param2,]).await
			
		}
		
	async fn mpool_clear(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolClear", vec![param1,param2,]).await
			
		}
		
	async fn mpool_get_config(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolGetConfig", vec![param1,]).await
			
		}
		
	async fn mpool_get_nonce(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolGetNonce", vec![param1,param2,]).await
			
		}
		
	async fn mpool_pending(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolPending", vec![param1,param2,]).await
			
		}
		
	async fn mpool_push(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolPush", vec![param1,param2,]).await
			
		}
		
	async fn mpool_push_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolPushMessage", vec![param1,param2,param3,]).await
			
		}
		
	async fn mpool_push_untrusted(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolPushUntrusted", vec![param1,param2,]).await
			
		}
		
	async fn mpool_select(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolSelect", vec![param1,param2,param3,]).await
			
		}
		
	async fn mpool_set_config(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MpoolSetConfig", vec![param1,param2,]).await
			
		}
		
	async fn mpool_sub(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("MpoolSub", vec![param1,]).await
			
		}
		
	async fn msig_add_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigAddApprove", vec![param1,param2,param3,param4,param5,param6,param7,]).await
			
		}
		
	async fn msig_add_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigAddCancel", vec![param1,param2,param3,param4,param5,param6,]).await
			
		}
		
	async fn msig_add_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigAddPropose", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn msig_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigApprove", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn msig_approve_txn_hash(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value, param8: Value, param9: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigApproveTxnHash", vec![param1,param2,param3,param4,param5,param6,param7,param8,param9,]).await
			
		}
		
	async fn msig_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigCancel", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn msig_cancel_txn_hash(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value, param8: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigCancelTxnHash", vec![param1,param2,param3,param4,param5,param6,param7,param8,]).await
			
		}
		
	async fn msig_create(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigCreate", vec![param1,param2,param3,param4,param5,param6,param7,]).await
			
		}
		
	async fn msig_get_available_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigGetAvailableBalance", vec![param1,param2,param3,]).await
			
		}
		
	async fn msig_get_pending(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigGetPending", vec![param1,param2,param3,]).await
			
		}
		
	async fn msig_get_vested(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigGetVested", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn msig_get_vesting_schedule(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigGetVestingSchedule", vec![param1,param2,param3,]).await
			
		}
		
	async fn msig_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigPropose", vec![param1,param2,param3,param4,param5,param6,param7,]).await
			
		}
		
	async fn msig_remove_signer(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigRemoveSigner", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn msig_swap_approve(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value, param7: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigSwapApprove", vec![param1,param2,param3,param4,param5,param6,param7,]).await
			
		}
		
	async fn msig_swap_cancel(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigSwapCancel", vec![param1,param2,param3,param4,param5,param6,]).await
			
		}
		
	async fn msig_swap_propose(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MsigSwapPropose", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn net_addrs_listen(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAddrsListen", vec![param1,]).await
			
		}
		
	async fn net_agent_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAgentVersion", vec![param1,param2,]).await
			
		}
		
	async fn net_auto_nat_status(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAutoNatStatus", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStats", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats_by_peer(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStatsByPeer", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats_by_protocol(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStatsByProtocol", vec![param1,]).await
			
		}
		
	async fn net_block_add(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockAdd", vec![param1,param2,]).await
			
		}
		
	async fn net_block_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockList", vec![param1,]).await
			
		}
		
	async fn net_block_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockRemove", vec![param1,param2,]).await
			
		}
		
	async fn net_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetConnect", vec![param1,param2,]).await
			
		}
		
	async fn net_connectedness(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetConnectedness", vec![param1,param2,]).await
			
		}
		
	async fn net_disconnect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetDisconnect", vec![param1,param2,]).await
			
		}
		
	async fn net_find_peer(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetFindPeer", vec![param1,param2,]).await
			
		}
		
	async fn net_peer_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPeerInfo", vec![param1,param2,]).await
			
		}
		
	async fn net_peers(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPeers", vec![param1,]).await
			
		}
		
	async fn net_pubsub_scores(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPubsubScores", vec![param1,]).await
			
		}
		
	async fn node_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NodeStatus", vec![param1,param2,]).await
			
		}
		
	async fn paych_allocate_lane(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychAllocateLane", vec![param1,param2,]).await
			
		}
		
	async fn paych_available_funds(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychAvailableFunds", vec![param1,param2,]).await
			
		}
		
	async fn paych_available_funds_by_from_to(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychAvailableFundsByFromTo", vec![param1,param2,param3,]).await
			
		}
		
	async fn paych_collect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychCollect", vec![param1,param2,]).await
			
		}
		
	async fn paych_get(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychGet", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn paych_get_wait_ready(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychGetWaitReady", vec![param1,param2,]).await
			
		}
		
	async fn paych_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychList", vec![param1,]).await
			
		}
		
	async fn paych_new_payment(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychNewPayment", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn paych_settle(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychSettle", vec![param1,param2,]).await
			
		}
		
	async fn paych_status(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychStatus", vec![param1,param2,]).await
			
		}
		
	async fn paych_voucher_add(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherAdd", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn paych_voucher_check_spendable(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherCheckSpendable", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn paych_voucher_check_valid(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherCheckValid", vec![param1,param2,param3,]).await
			
		}
		
	async fn paych_voucher_create(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherCreate", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn paych_voucher_list(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherList", vec![param1,param2,]).await
			
		}
		
	async fn paych_voucher_submit(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PaychVoucherSubmit", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn session(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Session", vec![param1,]).await
			
		}
		
	async fn shutdown(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Shutdown", vec![param1,]).await
			
		}
		
	async fn state_account_key(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateAccountKey", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_all_miner_faults(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateAllMinerFaults", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_call(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateCall", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_changed_actors(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateChangedActors", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_circulating_supply(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateCirculatingSupply", vec![param1,param2,]).await
			
		}
		
	async fn state_compute(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateCompute", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_deal_provider_collateral_bounds(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateDealProviderCollateralBounds", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_decode_params(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateDecodeParams", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn state_encode_params(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateEncodeParams", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_get_actor(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateGetActor", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_get_randomness_from_beacon(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateGetRandomnessFromBeacon", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn state_get_randomness_from_tickets(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateGetRandomnessFromTickets", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn state_list_actors(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateListActors", vec![param1,param2,]).await
			
		}
		
	async fn state_list_messages(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateListMessages", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_list_miners(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateListMiners", vec![param1,param2,]).await
			
		}
		
	async fn state_lookup_id(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateLookupID", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_market_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMarketBalance", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_market_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMarketDeals", vec![param1,param2,]).await
			
		}
		
	async fn state_market_participants(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMarketParticipants", vec![param1,param2,]).await
			
		}
		
	async fn state_market_storage_deal(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMarketStorageDeal", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_active_sectors(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerActiveSectors", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_available_balance(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerAvailableBalance", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_deadlines(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerDeadlines", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_faults(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerFaults", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_info(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerInfo", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_initial_pledge_collateral(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerInitialPledgeCollateral", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_miner_partitions(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerPartitions", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_miner_power(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerPower", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_pre_commit_deposit_for_power(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerPreCommitDepositForPower", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_miner_proving_deadline(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerProvingDeadline", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_recoveries(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerRecoveries", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_sector_allocated(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerSectorAllocated", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_miner_sector_count(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerSectorCount", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_miner_sectors(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateMinerSectors", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_network_name(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateNetworkName", vec![param1,]).await
			
		}
		
	async fn state_network_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateNetworkVersion", vec![param1,param2,]).await
			
		}
		
	async fn state_read_state(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateReadState", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_replay(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateReplay", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_search_msg(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateSearchMsg", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn state_sector_expiration(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateSectorExpiration", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_sector_get_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateSectorGetInfo", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_sector_partition(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateSectorPartition", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_sector_pre_commit_info(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateSectorPreCommitInfo", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn state_vm_circulating_supply_internal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateVMCirculatingSupplyInternal", vec![param1,param2,]).await
			
		}
		
	async fn state_verified_client_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateVerifiedClientStatus", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_verified_registry_root_key(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateVerifiedRegistryRootKey", vec![param1,param2,]).await
			
		}
		
	async fn state_verifier_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateVerifierStatus", vec![param1,param2,param3,]).await
			
		}
		
	async fn state_wait_msg(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StateWaitMsg", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn sync_check_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncCheckBad", vec![param1,param2,]).await
			
		}
		
	async fn sync_checkpoint(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncCheckpoint", vec![param1,param2,]).await
			
		}
		
	async fn sync_incoming_blocks(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("SyncIncomingBlocks", vec![param1,]).await
			
		}
		
	async fn sync_mark_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncMarkBad", vec![param1,param2,]).await
			
		}
		
	async fn sync_state(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncState", vec![param1,]).await
			
		}
		
	async fn sync_submit_block(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncSubmitBlock", vec![param1,param2,]).await
			
		}
		
	async fn sync_unmark_all_bad(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncUnmarkAllBad", vec![param1,]).await
			
		}
		
	async fn sync_unmark_bad(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncUnmarkBad", vec![param1,param2,]).await
			
		}
		
	async fn sync_validate_tipset(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SyncValidateTipset", vec![param1,param2,]).await
			
		}
		
	async fn version(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Version", vec![param1,]).await
			
		}
		
	async fn wallet_balance(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletBalance", vec![param1,param2,]).await
			
		}
		
	async fn wallet_default_address(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletDefaultAddress", vec![param1,]).await
			
		}
		
	async fn wallet_delete(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletDelete", vec![param1,param2,]).await
			
		}
		
	async fn wallet_export(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletExport", vec![param1,param2,]).await
			
		}
		
	async fn wallet_has(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletHas", vec![param1,param2,]).await
			
		}
		
	async fn wallet_import(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletImport", vec![param1,param2,]).await
			
		}
		
	async fn wallet_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletList", vec![param1,]).await
			
		}
		
	async fn wallet_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletNew", vec![param1,param2,]).await
			
		}
		
	async fn wallet_set_default(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletSetDefault", vec![param1,param2,]).await
			
		}
		
	async fn wallet_sign(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletSign", vec![param1,param2,param3,]).await
			
		}
		
	async fn wallet_sign_message(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletSignMessage", vec![param1,param2,param3,]).await
			
		}
		
	async fn wallet_validate_address(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletValidateAddress", vec![param1,param2,]).await
			
		}
		
	async fn wallet_verify(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WalletVerify", vec![param1,param2,param3,param4,]).await
			
		}
		
	}