// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.

// Code generated by github.com/tangle-network/lotus-client-schema-rs/rust-schemagen. DO NOT EDIT.
	
	use serde::{Deserialize, Serialize};
	use jsonrpc_core::Error;
	use serde_json::Value;
	use tokio::sync::mpsc;
	use crate::client::LotusClient;
	
	#[async_trait::async_trait]
	pub trait StorageMinerApi {
		
	async fn actor_address(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn actor_address_config(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn actor_sector_size(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn auth_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn auth_verify(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn check_provable(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn closing(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn compute_proof(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn create_backup(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn dagstore_gc(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn dagstore_initialize_all(&self, param1: Value, param2: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn dagstore_initialize_shard(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn dagstore_list_shards(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn dagstore_recover_shard(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_offline_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_offline_storage_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_online_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_online_storage_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_unverified_storage_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_consider_verified_storage_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_import_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn deals_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_piece_cid_blocklist(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_offline_retrieval_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_offline_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_online_retrieval_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_online_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_unverified_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_consider_verified_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn deals_set_piece_cid_blocklist(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn discover(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn id(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_alerts(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn log_set_level(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn market_cancel_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn market_data_transfer_diagnostics(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn market_data_transfer_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn market_get_ask(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_get_deal_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error>;
		
	async fn market_get_retrieval_ask(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_import_deal_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn market_list_data_transfers(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_list_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_list_incomplete_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_list_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_pending_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_publish_pending_deals(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn market_restart_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn market_retry_publish_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn market_set_ask(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error>;
		
	async fn market_set_retrieval_ask(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn mining_base(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_addrs_listen(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_agent_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_auto_nat_status(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats_by_peer(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_bandwidth_stats_by_protocol(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_add(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_block_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_connectedness(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_disconnect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_find_peer(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_peer_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn net_peers(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn net_pubsub_scores(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn pieces_get_cid_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn pieces_get_piece_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn pieces_list_cid_infos(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn pieces_list_pieces(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn pledge_sector(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn return_add_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_fetch(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_finalize_replica_update(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_finalize_sector(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_generate_sector_key_from_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_move_storage(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_prove_replica_update1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_prove_replica_update2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_read_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_release_unsealed(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn return_replica_update(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_seal_commit1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_seal_commit2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_seal_pre_commit1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_seal_pre_commit2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn return_unseal_piece(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn runtime_subsystems(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sealing_abort(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sealing_sched_diag(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_abort_upgrade(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_add_piece_to_any(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn sector_commit_flush(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_commit_pending(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_get_expected_seal_duration(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_get_seal_delay(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_mark_for_upgrade(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn sector_match_pending_pieces_to_open_sectors(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_pre_commit_flush(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_pre_commit_pending(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_set_expected_seal_duration(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_set_seal_delay(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_start_sealing(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_terminate(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sector_terminate_flush(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sector_terminate_pending(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_list_in_states(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_refs(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_summary(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_unseal_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error>;
		
	async fn sectors_update(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn session(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn shutdown(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn storage_add_local(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn storage_attach(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn storage_best_alloc(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn storage_declare_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn storage_drop_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn storage_find_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error>;
		
	async fn storage_get_locks(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn storage_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn storage_list(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn storage_local(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn storage_lock(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn storage_report_health(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error>;
		
	async fn storage_stat(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn storage_try_lock(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error>;
		
	async fn version(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn worker_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error>;
		
	async fn worker_jobs(&self, param1: Value) 
    -> Result<Value, Error>;
		
	async fn worker_stats(&self, param1: Value) 
    -> Result<Value, Error>;
		
	}
	
	#[derive(Debug, Clone)]
	pub struct StorageMinerClient {
		client: LotusClient,
	}
	
	#[async_trait::async_trait]
	impl StorageMinerApi for StorageMinerClient {
		
	async fn actor_address(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ActorAddress", vec![param1,]).await
			
		}
		
	async fn actor_address_config(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ActorAddressConfig", vec![param1,]).await
			
		}
		
	async fn actor_sector_size(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ActorSectorSize", vec![param1,param2,]).await
			
		}
		
	async fn auth_new(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("AuthNew", vec![param1,param2,]).await
			
		}
		
	async fn auth_verify(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("AuthVerify", vec![param1,param2,]).await
			
		}
		
	async fn check_provable(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("CheckProvable", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn closing(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("Closing", vec![param1,]).await
			
		}
		
	async fn compute_proof(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ComputeProof", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn create_backup(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("CreateBackup", vec![param1,param2,]).await
			
		}
		
	async fn dagstore_gc(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DagstoreGC", vec![param1,]).await
			
		}
		
	async fn dagstore_initialize_all(&self, param1: Value, param2: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("DagstoreInitializeAll", vec![param1,param2,]).await
			
		}
		
	async fn dagstore_initialize_shard(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DagstoreInitializeShard", vec![param1,param2,]).await
			
		}
		
	async fn dagstore_list_shards(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DagstoreListShards", vec![param1,]).await
			
		}
		
	async fn dagstore_recover_shard(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DagstoreRecoverShard", vec![param1,param2,]).await
			
		}
		
	async fn deals_consider_offline_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderOfflineRetrievalDeals", vec![param1,]).await
			
		}
		
	async fn deals_consider_offline_storage_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderOfflineStorageDeals", vec![param1,]).await
			
		}
		
	async fn deals_consider_online_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderOnlineRetrievalDeals", vec![param1,]).await
			
		}
		
	async fn deals_consider_online_storage_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderOnlineStorageDeals", vec![param1,]).await
			
		}
		
	async fn deals_consider_unverified_storage_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderUnverifiedStorageDeals", vec![param1,]).await
			
		}
		
	async fn deals_consider_verified_storage_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsConsiderVerifiedStorageDeals", vec![param1,]).await
			
		}
		
	async fn deals_import_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsImportData", vec![param1,param2,param3,]).await
			
		}
		
	async fn deals_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsList", vec![param1,]).await
			
		}
		
	async fn deals_piece_cid_blocklist(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsPieceCidBlocklist", vec![param1,]).await
			
		}
		
	async fn deals_set_consider_offline_retrieval_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderOfflineRetrievalDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_consider_offline_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderOfflineStorageDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_consider_online_retrieval_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderOnlineRetrievalDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_consider_online_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderOnlineStorageDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_consider_unverified_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderUnverifiedStorageDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_consider_verified_storage_deals(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetConsiderVerifiedStorageDeals", vec![param1,param2,]).await
			
		}
		
	async fn deals_set_piece_cid_blocklist(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("DealsSetPieceCidBlocklist", vec![param1,param2,]).await
			
		}
		
	async fn discover(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Discover", vec![param1,]).await
			
		}
		
	async fn id(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ID", vec![param1,]).await
			
		}
		
	async fn log_alerts(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogAlerts", vec![param1,]).await
			
		}
		
	async fn log_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogList", vec![param1,]).await
			
		}
		
	async fn log_set_level(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("LogSetLevel", vec![param1,param2,param3,]).await
			
		}
		
	async fn market_cancel_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketCancelDataTransfer", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn market_data_transfer_diagnostics(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketDataTransferDiagnostics", vec![param1,param2,]).await
			
		}
		
	async fn market_data_transfer_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("MarketDataTransferUpdates", vec![param1,]).await
			
		}
		
	async fn market_get_ask(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketGetAsk", vec![param1,]).await
			
		}
		
	async fn market_get_deal_updates(&self, param1: Value) 
    -> Result<mpsc::Receiver<Value>, Error> {
			
			self.client.subscribe("MarketGetDealUpdates", vec![param1,]).await
			
		}
		
	async fn market_get_retrieval_ask(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketGetRetrievalAsk", vec![param1,]).await
			
		}
		
	async fn market_import_deal_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketImportDealData", vec![param1,param2,param3,]).await
			
		}
		
	async fn market_list_data_transfers(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketListDataTransfers", vec![param1,]).await
			
		}
		
	async fn market_list_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketListDeals", vec![param1,]).await
			
		}
		
	async fn market_list_incomplete_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketListIncompleteDeals", vec![param1,]).await
			
		}
		
	async fn market_list_retrieval_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketListRetrievalDeals", vec![param1,]).await
			
		}
		
	async fn market_pending_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketPendingDeals", vec![param1,]).await
			
		}
		
	async fn market_publish_pending_deals(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketPublishPendingDeals", vec![param1,]).await
			
		}
		
	async fn market_restart_data_transfer(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketRestartDataTransfer", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn market_retry_publish_deal(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketRetryPublishDeal", vec![param1,param2,]).await
			
		}
		
	async fn market_set_ask(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketSetAsk", vec![param1,param2,param3,param4,param5,param6,]).await
			
		}
		
	async fn market_set_retrieval_ask(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MarketSetRetrievalAsk", vec![param1,param2,]).await
			
		}
		
	async fn mining_base(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("MiningBase", vec![param1,]).await
			
		}
		
	async fn net_addrs_listen(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAddrsListen", vec![param1,]).await
			
		}
		
	async fn net_agent_version(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAgentVersion", vec![param1,param2,]).await
			
		}
		
	async fn net_auto_nat_status(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetAutoNatStatus", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStats", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats_by_peer(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStatsByPeer", vec![param1,]).await
			
		}
		
	async fn net_bandwidth_stats_by_protocol(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBandwidthStatsByProtocol", vec![param1,]).await
			
		}
		
	async fn net_block_add(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockAdd", vec![param1,param2,]).await
			
		}
		
	async fn net_block_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockList", vec![param1,]).await
			
		}
		
	async fn net_block_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetBlockRemove", vec![param1,param2,]).await
			
		}
		
	async fn net_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetConnect", vec![param1,param2,]).await
			
		}
		
	async fn net_connectedness(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetConnectedness", vec![param1,param2,]).await
			
		}
		
	async fn net_disconnect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetDisconnect", vec![param1,param2,]).await
			
		}
		
	async fn net_find_peer(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetFindPeer", vec![param1,param2,]).await
			
		}
		
	async fn net_peer_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPeerInfo", vec![param1,param2,]).await
			
		}
		
	async fn net_peers(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPeers", vec![param1,]).await
			
		}
		
	async fn net_pubsub_scores(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("NetPubsubScores", vec![param1,]).await
			
		}
		
	async fn pieces_get_cid_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PiecesGetCIDInfo", vec![param1,param2,]).await
			
		}
		
	async fn pieces_get_piece_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PiecesGetPieceInfo", vec![param1,param2,]).await
			
		}
		
	async fn pieces_list_cid_infos(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PiecesListCidInfos", vec![param1,]).await
			
		}
		
	async fn pieces_list_pieces(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PiecesListPieces", vec![param1,]).await
			
		}
		
	async fn pledge_sector(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("PledgeSector", vec![param1,]).await
			
		}
		
	async fn return_add_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnAddPiece", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_fetch(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnFetch", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_finalize_replica_update(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnFinalizeReplicaUpdate", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_finalize_sector(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnFinalizeSector", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_generate_sector_key_from_data(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnGenerateSectorKeyFromData", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_move_storage(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnMoveStorage", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_prove_replica_update1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnProveReplicaUpdate1", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_prove_replica_update2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnProveReplicaUpdate2", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_read_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnReadPiece", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_release_unsealed(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnReleaseUnsealed", vec![param1,param2,param3,]).await
			
		}
		
	async fn return_replica_update(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnReplicaUpdate", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_seal_commit1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnSealCommit1", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_seal_commit2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnSealCommit2", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_seal_pre_commit1(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnSealPreCommit1", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_seal_pre_commit2(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnSealPreCommit2", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn return_unseal_piece(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("ReturnUnsealPiece", vec![param1,param2,param3,]).await
			
		}
		
	async fn runtime_subsystems(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("RuntimeSubsystems", vec![param1,]).await
			
		}
		
	async fn sealing_abort(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SealingAbort", vec![param1,param2,]).await
			
		}
		
	async fn sealing_sched_diag(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SealingSchedDiag", vec![param1,param2,]).await
			
		}
		
	async fn sector_abort_upgrade(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorAbortUpgrade", vec![param1,param2,]).await
			
		}
		
	async fn sector_add_piece_to_any(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorAddPieceToAny", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn sector_commit_flush(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorCommitFlush", vec![param1,]).await
			
		}
		
	async fn sector_commit_pending(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorCommitPending", vec![param1,]).await
			
		}
		
	async fn sector_get_expected_seal_duration(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorGetExpectedSealDuration", vec![param1,]).await
			
		}
		
	async fn sector_get_seal_delay(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorGetSealDelay", vec![param1,]).await
			
		}
		
	async fn sector_mark_for_upgrade(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorMarkForUpgrade", vec![param1,param2,param3,]).await
			
		}
		
	async fn sector_match_pending_pieces_to_open_sectors(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorMatchPendingPiecesToOpenSectors", vec![param1,]).await
			
		}
		
	async fn sector_pre_commit_flush(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorPreCommitFlush", vec![param1,]).await
			
		}
		
	async fn sector_pre_commit_pending(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorPreCommitPending", vec![param1,]).await
			
		}
		
	async fn sector_remove(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorRemove", vec![param1,param2,]).await
			
		}
		
	async fn sector_set_expected_seal_duration(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorSetExpectedSealDuration", vec![param1,param2,]).await
			
		}
		
	async fn sector_set_seal_delay(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorSetSealDelay", vec![param1,param2,]).await
			
		}
		
	async fn sector_start_sealing(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorStartSealing", vec![param1,param2,]).await
			
		}
		
	async fn sector_terminate(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorTerminate", vec![param1,param2,]).await
			
		}
		
	async fn sector_terminate_flush(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorTerminateFlush", vec![param1,]).await
			
		}
		
	async fn sector_terminate_pending(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorTerminatePending", vec![param1,]).await
			
		}
		
	async fn sectors_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsList", vec![param1,]).await
			
		}
		
	async fn sectors_list_in_states(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsListInStates", vec![param1,param2,]).await
			
		}
		
	async fn sectors_refs(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsRefs", vec![param1,]).await
			
		}
		
	async fn sectors_status(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsStatus", vec![param1,param2,param3,]).await
			
		}
		
	async fn sectors_summary(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsSummary", vec![param1,]).await
			
		}
		
	async fn sectors_unseal_piece(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value, param6: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsUnsealPiece", vec![param1,param2,param3,param4,param5,param6,]).await
			
		}
		
	async fn sectors_update(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("SectorsUpdate", vec![param1,param2,param3,]).await
			
		}
		
	async fn session(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Session", vec![param1,]).await
			
		}
		
	async fn shutdown(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Shutdown", vec![param1,]).await
			
		}
		
	async fn storage_add_local(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageAddLocal", vec![param1,param2,]).await
			
		}
		
	async fn storage_attach(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageAttach", vec![param1,param2,param3,]).await
			
		}
		
	async fn storage_best_alloc(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageBestAlloc", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn storage_declare_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageDeclareSector", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn storage_drop_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageDropSector", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn storage_find_sector(&self, param1: Value, param2: Value, param3: Value, param4: Value, param5: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageFindSector", vec![param1,param2,param3,param4,param5,]).await
			
		}
		
	async fn storage_get_locks(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageGetLocks", vec![param1,]).await
			
		}
		
	async fn storage_info(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageInfo", vec![param1,param2,]).await
			
		}
		
	async fn storage_list(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageList", vec![param1,]).await
			
		}
		
	async fn storage_local(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageLocal", vec![param1,]).await
			
		}
		
	async fn storage_lock(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageLock", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn storage_report_health(&self, param1: Value, param2: Value, param3: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageReportHealth", vec![param1,param2,param3,]).await
			
		}
		
	async fn storage_stat(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageStat", vec![param1,param2,]).await
			
		}
		
	async fn storage_try_lock(&self, param1: Value, param2: Value, param3: Value, param4: Value) 
    -> Result<Value, Error> {
			
			self.client.request("StorageTryLock", vec![param1,param2,param3,param4,]).await
			
		}
		
	async fn version(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("Version", vec![param1,]).await
			
		}
		
	async fn worker_connect(&self, param1: Value, param2: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WorkerConnect", vec![param1,param2,]).await
			
		}
		
	async fn worker_jobs(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WorkerJobs", vec![param1,]).await
			
		}
		
	async fn worker_stats(&self, param1: Value) 
    -> Result<Value, Error> {
			
			self.client.request("WorkerStats", vec![param1,]).await
			
		}
		
	}